
// Copyright (c) 2014, github.com/steforster/Remact.Net

// Classes in this file were generated by VisualStudio2008 (tool Svcutil.exe).
// V1.0: Manual adaption was needed to let the library user choose his WcfContract.Namespace.
// V2.0: Manual adaption was needed to run this under mono.
// V3.0: Added operation contract for async/await.

using System;
using System.ServiceModel;
using System.Threading;
#if !BEFORE_NET45
    using System.Threading.Tasks;
#endif

namespace Remact.Net.Internal
{
    //=========================================================================================
    /// <summary>
    /// The service interface is used internally. It must be public in order to access ClientBase&lt;IWcfBasic>
    /// </summary>
//    [ServiceContract( Namespace=RemactDefaults.WsNamespace, 
//                      ConfigurationName = "AsyncWcfLib.ClientContract")]
//    [ServiceKnownType( "z_GetServiceKnownTypes", typeof( WcfMessage ) )]
//    public interface IWcfBasic
//    {
//        /// <summary>
//        /// Synchronious send a request to a service.
//        /// </summary>
//        /// <param name="msg">The request message.</param>
//        /// <param name="id">Internally used identification info for a request (received and returned).</param>
//        /// <returns>The response message.</returns>
//        [OperationContract]
//          //Action=RemactDefaults.WsNamespace+"/IWcfBasic/WcfRequest",
//          //ReplyAction=RemactDefaults.WsNamespace+"/IWcfBasic/WcfRequestResponse")]
//        IWcfMessage WcfRequest (IWcfMessage msg, ref Request id);
//
//#if !BEFORE_NET45
//        /// <summary>
//        /// Send a request to a service and receive the response asynchronously (async-await pattern).
//        /// See http://blogs.msdn.com/b/endpoint/archive/2010/11/13/simplified-asynchronous-programming-model-in-wcf-with-async-await.aspx
//        /// </summary>
//        /// <param name="id">Internally used identification info for a request containing the request message.</param>
//        /// <returns>A Request containing the response message.</returns>
//        [OperationContract]
//        Task<Request> SendReceiveAsync (Request id);
//#endif
//    }// interface IWcfBasic


    //=========================================================================================
    internal partial class WcfBasicClient: System.ServiceModel.ClientBase<IWcfBasicContractSync>
    {
        // Constructors
        public WcfBasicClient(string endpointConfigurationName, 
                                WcfBasicClientAsync asyncClient)
        : base(endpointConfigurationName)
        {
            m_AsyncClient = asyncClient;
        }

        
        public WcfBasicClient(System.ServiceModel.Channels.Binding binding,
                                System.ServiceModel.EndpointAddress  remoteAddress,
                                WcfBasicClientAsync asyncClient)
        : base(binding, remoteAddress) 
        {
            m_AsyncClient = asyncClient;
        }

        internal new IWcfBasicContractSync Channel { get { return base.Channel; } }


        //----------------------------------------------------------------------------------------------------
        // Additions for mono V2.4 (run "mono -V" to get your version):
        // Mono does not support async operations so far.

        private  WcfBasicClientAsync m_AsyncClient;
        private  bool                m_boFirstResponseReceived;

        // Asynchronous open the connection
        internal void WcfOpenAsync (WcfBasicClientAsync asyncClient, Request id)
        {
            m_AsyncClient = asyncClient;
            m_boFirstResponseReceived = false;
            ThreadPool.UnsafeQueueUserWorkItem (OpenOnThreadpool, id);
        }

        private void OpenOnThreadpool(object idObj)
        {
          Request id = idObj as Request;
          SyncOpen(id);

          if (m_AsyncClient.ClientIdent.IsMultithreaded)
          {
            m_AsyncClient.OnOpenCompleted (id); // Test1.ClientNoSync, RouterClient
          }
          else if (m_AsyncClient.ClientIdent.SyncContext == null)
          {
            RaTrc.Error( "AsyncWcfLib", "No synchronization context to open " + m_AsyncClient.ClientIdent.Name, m_AsyncClient.ClientIdent.Logger );
            m_AsyncClient.OnOpenCompleted (id);
          }
          else
          {
            m_AsyncClient.ClientIdent.SyncContext.Post (m_AsyncClient.OnOpenCompleted, id);
          }
        }// OpenOnThreadpool


        internal void SyncOpen (Request id)
        {
            try
            {
                base.Open();
                id.Message = null; // null = ok
            }
            catch (EndpointNotFoundException ex)
            {
                id.Message = new ErrorMessage(ErrorMessage.Code.ServiceNotRunning, ex);
            }
            catch (Exception ex)
            {
                id.Message = new ErrorMessage(ErrorMessage.Code.CouldNotOpen, ex);
            }
        }// SyncOpen


        // class to hold state during receive operation
        internal class ReceivingState
        {
          internal Request idSnd;
          internal Request idRcv;
          internal bool        timeout;
          internal bool        disposed;
        }


        // Asynchronous send a request
        internal void WcfRequestAsync (Request id)
        {
          // Variant a) 240 Reqests/sec + blocks client !!!!!! in Test2
          //IWcfMessage msg = id.Message;
          //id.Message = null; // do not keep msg until response is received.
          //m_SendDelegate =  base.Channel.WcfRequest;
          //m_SendDelegate.BeginInvoke (msg, ref id, OnRequestCompletedInThreadpool, id); // sending in a threadpool thread
          //-----------
          // Variant b) 1100 Reqests/sec in Test2
          ThreadPool.UnsafeQueueUserWorkItem (SendOnThreadpool, id);
        }

        private void SendOnThreadpool (object idObj)
        {
            ReceivingState data = SyncSend (idObj as Request);

            if (data.disposed)
            {
                return; // probably disconnected
            }

            if (m_AsyncClient.ClientIdent.IsMultithreaded || m_AsyncClient.ClientIdent.SyncContext == null)
            {
                m_AsyncClient.OnRequestCompleted (data); // Test1.ClientNoSync, RouterClient
            }
            else
            {
                m_AsyncClient.ClientIdent.SyncContext.Post (m_AsyncClient.OnRequestCompleted, data);
            }
        }


        // Synchronous send a request
        internal ReceivingState SyncSend (Request id)
        {
            ReceivingState data = new ReceivingState();
            try
            {
                data.idSnd = id;
                data.idRcv = id;
                IWcfMessage msg = base.Channel.WcfRequest(data.idSnd.Message, ref data.idRcv);
                if (msg == null)
                {
                    msg = new ErrorMessage(ErrorMessage.Code.RspNotDeserializableOnClient, "<null> message received");
                }
                data.idSnd.Message = null; // not used anymore
                data.idRcv.Message = msg;
            }
            catch (Exception ex)
            {
                HandleSendException (data, ex);
            }
            return data;
        }// SyncSend


        internal void HandleSendException(ReceivingState data, Exception ex)
        {
            //RaTrc.Exception("Could not send to Wcf service", ex);
            ErrorMessage.Code Code;
            bool onSvc = false;

            if (ex is System.Reflection.TargetInvocationException)
            {
                ex = (ex as System.Reflection.TargetInvocationException).InnerException;
                onSvc = true;
            }

            if (ex is TimeoutException)
            {
                if (onSvc) Code = ErrorMessage.Code.TimeoutOnService;
                else Code = ErrorMessage.Code.TimeoutOnClient;
                data.timeout = true;
            }
            else if (ex is ProtocolException)
            {
                Code = ErrorMessage.Code.RequestTypeUnknownOnService;
            }
            else if (ex is FaultException)
            { // including FaultException<TDetail>
                Code = ErrorMessage.Code.ReqOrRspNotSerializableOnService;
                onSvc = true;
                data.timeout = true; // stop sending, enter Faulted state
            }
            else if (ex is CommunicationException)
            {
                if (!m_boFirstResponseReceived) Code = ErrorMessage.Code.CouldNotConnect;
                else Code = ErrorMessage.Code.ReqOrRspNotSerializableOnService; // ???
                data.timeout = true; // stop sending, enter Faulted state
            }
            else if (ex is ObjectDisposedException && !onSvc)
            {
                Code = ErrorMessage.Code.CouldNotSend;
                data.timeout = true;
                data.disposed = true;
            }
            else
            {
                if (onSvc) Code = ErrorMessage.Code.ClientDetectedUnhandledExceptionOnService;
                else Code = ErrorMessage.Code.CouldNotSend;
                data.timeout = true; // stop sending, enter Faulted state
            }
            m_boFirstResponseReceived = true;
            data.idSnd.Message = null; // Send and Receive normally point to the same id
            data.idRcv.Message = new ErrorMessage(Code, ex);
        }

    }// class WcfBasicClient

}//namespace
